generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String
  lastName  String
  password  String // Stored as a bcrypt hash
  isVerified Boolean  @default(false)
  role      UserRole  @default(VIEWER)

  refreshTokens RefreshToken[]
  products      Product[] // A user can create many products
  otps          Otp[]     // Add this relation
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum OtpType {
  EMAIL_VERIFICATION
  LOGIN_VERIFICATION
  PASSWORD_RESET
}

model Otp {
  id          String   @id @default(cuid())
  otpHash     String
  expiresAt   DateTime
  type        OtpType
  used        Boolean  @default(false)
  
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())

  @@index([userId, type])
}

enum UserRole {
  ADMIN
  EDITOR
  VIEWER
}

model RefreshToken {
  id          String   @id @default(cuid())
  hashedToken String
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  revoked     Boolean  @default(false)

  @@unique([userId, hashedToken])
}

model RawMaterial {
  id             String   @id @default(cuid())
  name           String   @unique
  // Cost is stored as Decimal for precision, representing cost per quintal
  costPerQuintal Decimal  @db.Decimal(10, 2)
  
  // Relationships
  ingredients    ProductIngredient[]
  priceHistory   PriceHistory[]

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Product {
  id                       String   @id @default(cuid())
  name                     String
  // This is the "additionalCost" you mentioned, also per quintal
  additionalCostPerQuintal Decimal  @db.Decimal(10, 2) @default(0.00)

  // Relationships
  ingredients ProductIngredient[]
  userId      String
  user        User                @relation(fields: [userId], references: [id], onDelete: Restrict) // Protects from user deletion

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, name]) // A user cannot have two products with the same name
}

// This is the "join table" that connects Products and RawMaterials
// It stores the percentage of each ingredient in a product
model ProductIngredient {
  id            String   @id @default(cuid())
  percentage    Decimal  @db.Decimal(5, 2) // e.g., 25.50 (for 25.50%)

  // Relationships
  productId     String
  product       Product  @relation(fields: [productId], references: [id], onDelete: Cascade) // If product is deleted, this entry is deleted
  rawMaterialId String
  rawMaterial   RawMaterial @relation(fields: [rawMaterialId], references: [id], onDelete: Restrict) // Don't delete material if it's in a product

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([productId, rawMaterialId]) // A product can only have a specific ingredient once
}

// For Phase 2: Historical Price Tracking
model PriceHistory {
  id             String   @id @default(cuid())
  rawMaterialId  String
  rawMaterial    RawMaterial @relation(fields: [rawMaterialId], references: [id], onDelete: Cascade)
  oldCost        Decimal     @db.Decimal(10, 2)
  newCost        Decimal     @db.Decimal(10, 2)
  changedAt      DateTime    @default(now())
}